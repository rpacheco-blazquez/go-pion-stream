<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>WebRTC Color Sender</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            overflow-y: auto;
            font-family: sans-serif;
        }

        .container {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            background-color: #f4f4f4;
            overflow-y: auto;
        }

        .header {
            height: 12vh;
            min-height: 60px;
            padding: 1em;
            background-color: #007bff;
            color: #fff;
            width: 100%;
            text-align: center;
            box-sizing: border-box;
            justify-content: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header h2 {
            font-size: 4em;
        }

        .video-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 95%;
            margin: 0 auto;
            max-height: 60vh;
            height: 60vh;
            min-height: 180px;
            box-sizing: border-box;
        }

        video {
            width: 95%;
            max-width: 95%;
            height: 60vh;
            max-height: 60vh;
            border: 2px solid #333;
            background: #000;
            display: block;
        }

        @media (max-width: 600px) {
            .container {
                max-height: 90vh;
            }

            .footer {
                padding: 2.5em 0.2em 2.5em 0.2em;
            }

            button {
                font-size: 2.7em;
                padding: 1.5em 0;
                width: 99vw;
                min-width: 120px;
                max-width: 100vw;
                margin-top: 2em;
            }

            input,
            select {
                font-size: 3em !important;
                padding: 1.5em !important;
                max-width: 99vw !important;
                margin-top: 1.2em !important;
                height: auto !important;
            }

            label {
                font-size: 1.7em;
            }

            .video-container {
                max-height: 55vw;
            }

            video {
                height: 45vw;
                max-height: 55vw;
                max-width: 99vw;
            }
        }

        .footer {
            flex: 0 0 10%;
            padding: 1.2em 0.5em 1.2em 0.5em;
            width: 100%;
            text-align: center;
            height: 85vh;
        }

        button {
            padding: 1em 0;
            font-size: 4em;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            width: 95%;
            min-width: 140px;
            max-width: 95%;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
            margin: 1.2em auto 0 auto;
            display: block;
        }

        button:enabled:hover {
            background-color: #0056b3;
            transform: scale(1.05);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }

        button:disabled {
            background-color: #b0b0b0 !important;
            color: #eee !important;
            cursor: not-allowed !important;
            box-shadow: none !important;
            transform: none !important;
            opacity: 0.7;
        }

        #status {
            margin-top: 1em;
            font-size: 2em;
            color: #555;
        }

        input {
            padding: 0.7em;
            font-size: 4em;
            border: 2px solid #007bff;
            border-radius: 5px;
            margin-top: 0.7em;
            width: 95% !important;
            min-width: 140px !important;
            max-width: 95% !important;

            text-transform: uppercase;
        }

        label {
            font-size: 4em;
            color: #333;
            margin-top: 0.7em;
            display: block;
        }

        select {
            padding: 0.7em;
            font-size: 4em;
            border: 2px solid #007bff;
            border-radius: 5px;
            margin-top: 0.7em;
            width: 95% !important;
            min-width: 140px !important;
            max-width: 95% !important;
        }

        @media (max-width: 600px) {
            .container {
                max-height: 90vh;
            }

            .footer {
                padding: 1.5em 0.2em 1.5em 0.2em;
            }

            button {
                font-size: 2.3em;
                padding: 1.2em 0;
                width: 98%;
                min-width: 120px;
                max-width: 100vw;
            }

            input,
            select {
                font-size: 1.7em;
                padding: 1em;
                max-width: 98vw;
            }

            label {
                font-size: 1.4em;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h2>WebRTC Cámara y Micro</h2>
        </div>
        <div class="video-container">
            <video id="localVideo" autoplay muted playsinline></video>
        </div>
        <div class="footer">
            <label for="channelCode">Código del canal:</label>
            <input type="text" id="channelCode" placeholder="Introduce el código del canal">
            <label for="cameraSelect">Selecciona la cámara:</label>
            <select id="cameraSelect">
                <option value="user">Cámara Frontal</option>
                <option value="environment">Cámara Trasera</option>
            </select>
            <button id="sendBtn">Enviar cámara y micro por WebRTC</button>
            <div id="status"></div>
        </div>

        <script>
            const video = document.getElementById('localVideo');
            const sendBtn = document.getElementById('sendBtn');
            const statusDiv = document.getElementById('status');
            const channelCodeInput = document.getElementById('channelCode');
            const cameraSelect = document.getElementById('cameraSelect');
            let pc = null;
            let currentStream = null;
            let lastSentConfig = { channel: '', camera: '' };

            function cleanupConnection() {
                // Cierra la conexión WebRTC y detiene los tracks
                if (pc) {
                    try { pc.close(); } catch (e) { }
                    pc = null;
                }
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                    currentStream = null;
                }
                video.srcObject = null;
            }

            sendBtn.onclick = async () => {
                const channelCode = channelCodeInput.value.trim();
                const deviceId = cameraSelect.value;
                if (!channelCode) {
                    alert('Por favor, introduce un código de canal.');
                    return;
                }

                sendBtn.disabled = true;
                statusDiv.textContent = 'Solicitando cámara y micro...';

                cleanupConnection(); // Siempre limpiar antes de crear uno nuevo

                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert('Tu navegador no soporta acceso a la cámara. Por favor, usa un navegador actualizado.');
                    sendBtn.disabled = false;
                    return;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { deviceId: { exact: deviceId } },
                        audio: true
                    });
                    video.srcObject = stream;
                    currentStream = stream;
                    statusDiv.textContent = 'Cámara y micro capturados. Iniciando WebRTC...';

                    pc = new RTCPeerConnection();
                    stream.getTracks().forEach(track => {
                        pc.addTrack(track, stream);
                    });

                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);

                    const resp = await fetch(`/stream?code=${encodeURIComponent(channelCode)}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            type: offer.type,
                            sdp: offer.sdp
                        })
                    });

                    if (!resp.ok) {
                        const errorText = await resp.text();
                        statusDiv.textContent = `Error: ${errorText}`;
                        sendBtn.disabled = false;
                        return;
                    }

                    const answer = await resp.json();
                    await pc.setRemoteDescription(answer);
                    statusDiv.textContent = 'WebRTC conectado. Enviando cámara y micro.';

                    // Guardar la última combinación enviada
                    lastSentConfig = { channel: channelCode, camera: deviceId };
                    updateSendBtnState();
                } catch (err) {
                    if (err.name === 'NotAllowedError') {
                        alert('Permiso denegado para acceder a la cámara y el micrófono.');
                    } else if (err.name === 'NotFoundError') {
                        alert('No se encontró una cámara o micrófono disponible.');
                    } else {
                        alert('Error al acceder a la cámara: ' + err.message);
                    }
                    sendBtn.disabled = false;
                }
            };

            // Al cambiar de cámara o canal, solo actualizar el estado del botón
            function onCameraOrChannelChange() {
                updateSendBtnState();
                statusDiv.textContent = 'Cámara/canal cambiado. Pulsa Enviar para reconectar.';
            }

            // Habilita el botón solo si la combinación es diferente a la última enviada
            function updateSendBtnState() {
                const channelCode = channelCodeInput.value.trim();
                const deviceId = cameraSelect.value;
                const isDifferent = channelCode && (channelCode !== lastSentConfig.channel || deviceId !== lastSentConfig.camera);
                sendBtn.disabled = !isDifferent;
            }

            // Listar cámaras disponibles
            async function listAvailableCameras() {
                try {
                    // Solicitar permisos de cámara para garantizar que se detecten los dispositivos
                    await navigator.mediaDevices.getUserMedia({ video: true });

                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');

                    cameraSelect.innerHTML = '';

                    videoDevices.forEach((device, index) => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.textContent = device.label || `Cámara ${index + 1}`;
                        cameraSelect.appendChild(option);
                    });

                    if (videoDevices.length === 0) {
                        statusDiv.textContent = 'No se detectaron cámaras disponibles.';
                    }
                } catch (err) {
                    console.error('Error al listar cámaras:', err);
                    statusDiv.textContent = 'Error al listar cámaras. Asegúrate de otorgar permisos.';
                }
            }

            listAvailableCameras();
            cameraSelect.addEventListener('change', onCameraOrChannelChange);
            // Forzar mayúsculas en el input y actualizar estado
            channelCodeInput.addEventListener('input', (e) => {
                const start = channelCodeInput.selectionStart;
                const end = channelCodeInput.selectionEnd;
                channelCodeInput.value = channelCodeInput.value.toUpperCase();
                channelCodeInput.setSelectionRange(start, end);
                onCameraOrChannelChange();
            });
            // Inicializar el estado del botón al cargar
            updateSendBtnState();
        </script>
    </div>
</body>

</html>