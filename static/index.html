<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>WebRTC Stream Sender</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 2em;
        }

        video {
            width: 320px;
            border: 1px solid #888;
            margin-bottom: 1em;
        }

        #status {
            margin-top: 1em;
            font-weight: bold;
        }

        button {
            padding: 0.5em 1em;
            font-size: 1em;
        }
    </style>
</head>

<body>
    <h2>Enviar cámara y micro al backend WebRTC</h2>
    <video id="localVideo" autoplay muted playsinline></video><br>
    <button id="startBtn">Iniciar envío</button>
    <div id="status">Esperando acción...</div>
    <script>
        const startBtn = document.getElementById('startBtn');
        const statusDiv = document.getElementById('status');
        const localVideo = document.getElementById('localVideo');
        let pc;

        startBtn.onclick = async () => {
            startBtn.disabled = true;
            statusDiv.textContent = 'Solicitando cámara y micro...';
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = stream;
                statusDiv.textContent = 'Cámara y micro OK. Creando conexión...';
                console.log('Tracks obtenidos:', stream.getTracks().map(t => t.kind + ':' + t.id));
                pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: "stun:stun.l.google.com:19302" }
                    ]
                });
                pc.onicecandidate = (e) => {
                    if (e.candidate) console.log('ICE candidate:', e.candidate.candidate);
                    else console.log('ICE gathering complete');
                };
                pc.oniceconnectionstatechange = () => {
                    statusDiv.textContent = 'ICE: ' + pc.iceConnectionState;
                    console.log('ICE connection state:', pc.iceConnectionState);
                };
                pc.onconnectionstatechange = () => {
                    console.log('PeerConnection state:', pc.connectionState);
                };
                pc.onnegotiationneeded = () => {
                    console.log('Negotiation needed');
                };
                pc.ontrack = (e) => {
                    console.log('ontrack (remoto) recibido:', e.track.kind, e.track.id);
                };
                stream.getTracks().forEach(track => {
                    pc.addTrack(track, stream);
                    console.log('Track añadido al PeerConnection:', track.kind, track.id);
                });
                statusDiv.textContent += '\nTracks añadidos: ' + stream.getTracks().map(t => t.kind).join(', ');
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                statusDiv.textContent = 'Enviando oferta al backend...';
                const response = await fetch('/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(pc.localDescription)
                });
                const answer = await response.json();
                await pc.setRemoteDescription(answer);
                statusDiv.textContent = '¡Enviando vídeo y audio al backend!';
                console.log('Oferta enviada y respuesta recibida. Estado final:', pc.iceConnectionState);
            } catch (e) {
                statusDiv.textContent = 'Error: ' + e;
                startBtn.disabled = false;
                console.error(e);
            }
        };
    </script>
</body>

</html>