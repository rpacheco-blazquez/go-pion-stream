// package webrtc

// import (
// 	"bytes"
// 	"image/jpeg"
// 	"image/png"
// 	"io"
// 	"log"
// 	"math/rand"
// 	"os"
// 	"os/exec"
// 	"time"
// )

// // RunFFmpegWEBM ejecuta ffmpeg para grabar 5 segundos de RTP a un archivo WebM
// func RunFFmpegWEBM(outputFile string) error {
// 	log.Println("[FFmpeg] Lanzando ffmpeg para grabar 5 segundos a WebM...")
// 	cmd := exec.Command(
// 		"ffmpeg",
// 		"-loglevel", "debug",
// 		"-protocol_whitelist", "file,udp,rtp",
// 		"-i", "rtp-forwarder.sdp",
// 		"-t", "5",
// 		"-c:v", "copy",
// 		outputFile,
// 	)
// 	cmd.Dir = "."
// 	stderr, err := cmd.StderrPipe()
// 	if err != nil {
// 		log.Printf("[FFmpeg] Error creando StderrPipe: %v", err)
// 		return err
// 	}
// 	if err := cmd.Start(); err != nil {
// 		log.Printf("[FFmpeg] Error lanzando ffmpeg: %v", err)
// 		return err
// 	}
// 	go func() {
// 		// Leer y volcar stderr de ffmpeg al log de Go
// 		buf := make([]byte, 4096)
// 		for {
// 			n, err := stderr.Read(buf)
// 			if n > 0 {
// 				log.Printf("[FFmpeg-STDERR] %s", buf[:n])
// 			}
// 			if err != nil {
// 				break
// 			}
// 		}
// 	}()
// 	err = cmd.Wait()
// 	if err != nil {
// 		log.Printf("[FFmpeg] ffmpeg terminó con error: %v", err)
// 	} else {
// 		log.Printf("[FFmpeg] Grabación WebM finalizada: %s", outputFile)
// 	}
// 	return err
// }

// // RunFFmpegMJPEGTestFiles ejecuta ffmpeg para volcar JPEGs a archivos.
// // Sirve como prueba para confirmar que el pipeline RTP → JPEG funciona.
// func RunFFmpegMJPEGTestFiles() error {
// 	log.Println("[FFmpeg] Lanzando ffmpeg para volcar JPEGs en archivos...")

// 	cmd := exec.Command(
// 		"ffmpeg",
// 		"-loglevel", "debug",
// 		"-protocol_whitelist", "file,udp,rtp",
// 		"-i", "rtp-forwarder.sdp",
// 		"-vf", "fps=5,scale=960:540",
// 		"-pix_fmt", "yuvj420p",
// 		"-q:v", "5",
// 		"frame-%05d.jpg",
// 	)
// 	cmd.Dir = "."

// 	stderr, err := cmd.StderrPipe()
// 	if err != nil {
// 		log.Printf("[FFmpeg] Error creando StderrPipe: %v", err)
// 		return err
// 	}
// 	if err := cmd.Start(); err != nil {
// 		log.Printf("[FFmpeg] Error lanzando ffmpeg: %v", err)
// 		return err
// 	}

// 	// Captura stderr para debug
// 	go func() {
// 		buf := make([]byte, 4096)
// 		for {
// 			n, err := stderr.Read(buf)
// 			if n > 0 {
// 				log.Printf("[FFmpeg-STDERR] %s", buf[:n])
// 			}
// 			if err != nil {
// 				break
// 			}
// 		}
// 	}()

// 	return cmd.Wait()
// }

// // RunFFmpegToMJPEG lanza ffmpeg para leer rtp-forwarder.sdp y emite una corriente
// // de JPEGs por stdout (image2pipe / mjpeg). Esta función parsea stdout por SOI/EOI
// // y llama a broadcastFrame([]byte) para enviar cada JPEG a los clientes.
// func RunFFmpegToMJPEG() error {
// 	log.Println("[FFmpeg] Lanzando ffmpeg en modo image2pipe para MJPEG (RunFFmpegToMJPEG)...")

// 	// Comando: ffmpeg -> salida mjpeg a pipe:1 (separados por SOI/EOI)
// 	cmd := exec.Command(
// 		"ffmpeg",
// 		"-loglevel", "info",
// 		"-nostdin",
// 		"-protocol_whitelist", "file,udp,rtp",
// 		"-re",
// 		"-i", "rtp-forwarder.sdp",
// 		"-flags", "low_delay",
// 		"-avioflags", "direct",
// 		"-analyzeduration", "0",
// 		"-probesize", "32k",
// 		"-use_wallclock_as_timestamps", "1",
// 		"-vf", "fps=10,scale=960:540",
// 		"-pix_fmt", "yuvj420p",
// 		"-flush_packets", "1",
// 		"-f", "mjpeg", // produce una secuencia de JPEGs
// 		"-q:v", "5",
// 		"pipe:1",
// 	)
// 	cmd.Dir = "."

// 	stdout, err := cmd.StdoutPipe()
// 	if err != nil {
// 		log.Printf("[FFmpeg] Error creando StdoutPipe: %v", err)
// 		return err
// 	}
// 	stderr, err := cmd.StderrPipe()
// 	if err != nil {
// 		log.Printf("[FFmpeg] Error creando StderrPipe: %v", err)
// 		return err
// 	}

// 	if err := cmd.Start(); err != nil {
// 		log.Printf("[FFmpeg] Error lanzando ffmpeg: %v", err)
// 		return err
// 	}

// 	// Goroutine para volcar stderr a logs (útil para debugging)
// 	go func() {
// 		defer stderr.Close()
// 		buf := make([]byte, 4096)
// 		for {
// 			n, rerr := stderr.Read(buf)
// 			if n > 0 {
// 				// Trimear salto final para logs más claros
// 				log.Printf("[FFmpeg-STDERR] %s", bytes.TrimRight(buf[:n], "\r\n"))
// 			}
// 			if rerr != nil {
// 				if rerr != io.EOF {
// 					log.Printf("[FFmpeg-STDERR] lectura terminó con error: %v", rerr)
// 				}
// 				break
// 			}
// 		}
// 	}()

// 	// Goroutine para parsear stdout y distribuir frames
// 	go func() {
// 		defer stdout.Close()
// 		// buffer para acumular datos entrantes
// 		buf := make([]byte, 0, 2*1024*1024) // 2MB inicial
// 		tmp := make([]byte, 64*1024)        // leer en chunks de 64KB

// 		jpegSOI := []byte{0xFF, 0xD8}
// 		jpegEOI := []byte{0xFF, 0xD9}

// 		lastLog := time.Now().Add(-time.Minute)

// 		for {
// 			n, rerr := stdout.Read(tmp)
// 			if n > 0 {
// 				buf = append(buf, tmp[:n]...)

// 				// extraer todos los JPEG completos del buffer
// 				for {
// 					start := bytes.Index(buf, jpegSOI)
// 					if start < 0 {
// 						break
// 					}
// 					endRel := bytes.Index(buf[start:], jpegEOI)
// 					if endRel < 0 {
// 						break
// 					}
// 					end := start + endRel + 2 // posición del byte después de EOI

// 					// Copia defensiva del frame
// 					frame := append([]byte(nil), buf[start:end]...)

// 					// Envía el frame al hub (broadcast no bloqueante)
// 					broadcastFrame(frame)

// 					// recorta buffer
// 					buf = buf[end:]
// 				}

// 				// Evitar un buffer descontrolado por si ffmpeg produce basura
// 				if len(buf) > 16*1024*1024 { // 16MB umbral
// 					// loguear de forma limitada para no spamear el log
// 					if time.Since(lastLog) > 5*time.Second {
// 						log.Printf("[FFmpeg] Warning: buffer creció a %d bytes, truncando", len(buf))
// 						lastLog = time.Now()
// 					}
// 					buf = buf[:0]
// 				}
// 			}

// 			if rerr != nil {
// 				if rerr != io.EOF {
// 					log.Printf("[FFmpeg] Error leyendo stdout: %v", rerr)
// 				}
// 				break
// 			}
// 		}

// 		log.Println("[FFmpeg] Lectura de stdout finalizada (parser) — ffmpeg quizá terminó")
// 	}()

// 	// Esperamos a que ffmpeg termine (la goroutine anterior seguirá procesando hasta el EOF)
// 	if err := cmd.Wait(); err != nil {
// 		log.Printf("[FFmpeg] ffmpeg finalizó con error: %v", err)
// 		return err
// 	}

// 	log.Println("[FFmpeg] ffmpeg terminó correctamente")
// 	return nil
// }

// // RunFFmpegMJPEGtoFile ejecuta ffmpeg leyendo rtp-forwarder.sdp y escribe un fichero MJPEG en disco.
// // Si falla al inicializar el encoder MJPEG, intenta un fallback que escribe frame-%05d.jpg (probeable).
// func RunFFmpegMJPEGtoFile(filename string) error {
// 	log.Println("[FFmpeg->File] Lanzando ffmpeg para volcar MJPEG en fichero:", filename)

// 	// Eliminar fichero previo si existe (para evitar "already exists")
// 	if _, err := os.Stat(filename); err == nil {
// 		if err := os.Remove(filename); err != nil {
// 			log.Printf("[FFmpeg->File] Advertencia: no se pudo borrar %s antes de lanzar ffmpeg: %v", filename, err)
// 		} else {
// 			log.Printf("[FFmpeg->File] Fichero previo %s eliminado.", filename)
// 		}
// 	}

// 	// Comando saneado: quitamos -flags low_delay y -avioflags direct que producen problemas al encoder MJPEG
// 	cmd := exec.Command(
// 		"ffmpeg",
// 		"-y", // overwrite
// 		"-loglevel", "debug",
// 		"-nostdin",
// 		"-protocol_whitelist", "file,udp,rtp",
// 		"-i", "rtp-forwarder.sdp",
// 		"-an", // no audio in MJPEG file
// 		"-vf", "fps=10,scale=960:540",
// 		"-c:v", "mjpeg",
// 		"-q:v", "5",
// 		"-r", "10", // framerate de salida estable
// 		"-f", "mjpeg",
// 		filename,
// 	)
// 	cmd.Dir = "."

// 	stderr, err := cmd.StderrPipe()
// 	if err != nil {
// 		log.Printf("[FFmpeg->File] Error creando StderrPipe: %v", err)
// 		return err
// 	}

// 	if err := cmd.Start(); err != nil {
// 		log.Printf("[FFmpeg->File] Error lanzando ffmpeg: %v", err)
// 		return err
// 	}

// 	// Leer stderr en goroutine
// 	doneStderr := make(chan struct{})
// 	go func() {
// 		defer close(doneStderr)
// 		defer stderr.Close()
// 		buf := make([]byte, 4096)
// 		for {
// 			n, rerr := stderr.Read(buf)
// 			if n > 0 {
// 				log.Printf("[FFmpeg-STDERR] %s", bytes.TrimRight(buf[:n], "\r\n"))
// 			}
// 			if rerr != nil {
// 				if rerr != io.EOF {
// 					log.Printf("[FFmpeg-STDERR] Lectura stderr terminó con error: %v", rerr)
// 				}
// 				return
// 			}
// 		}
// 	}()

// 	// Watcher: informa del tamaño del fichero cada segundo (útil para debug)
// 	watchDone := make(chan struct{})
// 	go func() {
// 		defer close(watchDone)
// 		ticker := time.NewTicker(1 * time.Second)
// 		defer ticker.Stop()
// 		timeout := time.After(10 * time.Second) // miro 10s, si no crece, asumimos fallo y hacemos fallback
// 		for {
// 			select {
// 			case <-ticker.C:
// 				if fi, err := os.Stat(filename); err == nil {
// 					log.Printf("[FFmpeg->File] Tamaño actual de %s: %d bytes", filename, fi.Size())
// 				} else {
// 					log.Printf("[FFmpeg->File] %s no existe todavía (%v)", filename, err)
// 				}
// 			case <-timeout:
// 				return
// 			}
// 		}
// 	}()

// 	// Esperar a que el proceso termine (pero primero esperar el watcher unos segundos)
// 	waitErr := cmd.Wait()

// 	// Esperamos a que stderr/watcher terminen de forma limpia
// 	<-doneStderr
// 	<-watchDone

// 	if waitErr != nil {
// 		log.Printf("[FFmpeg->File] ffmpeg finalizó con error: %v", waitErr)

// 		// Fallback: escribir JPEGs por frame (esto SI que sabemos que funcionó en tu máquina)
// 		fallbackName := "frame-%05d.jpg"
// 		log.Println("[FFmpeg->File] Iniciando fallback: volcar frames individuales a", fallbackName)
// 		if fbErr := runFFmpegFallbackFrames(fallbackName); fbErr != nil {
// 			log.Printf("[FFmpeg->File] Fallback también falló: %v", fbErr)
// 			return waitErr // devolvemos el error original de MJPEG
// 		}
// 		return nil
// 	}

// 	log.Println("[FFmpeg->File] ffmpeg finalizó correctamente, fichero generado:", filename)
// 	return nil
// }

// func runFFmpegFallbackFrames(pattern string) error {
// 	cmd := exec.Command(
// 		"ffmpeg",
// 		"-y",
// 		"-loglevel", "debug",
// 		"-nostdin",
// 		"-protocol_whitelist", "file,udp,rtp",
// 		"-i", "rtp-forwarder.sdp",
// 		"-an",
// 		"-vf", "fps=5,scale=960:540",
// 		"-q:v", "5",
// 		pattern,
// 	)
// 	stderr, err := cmd.StderrPipe()
// 	if err != nil {
// 		return err
// 	}
// 	if err := cmd.Start(); err != nil {
// 		return err
// 	}
// 	// leer stderr (no bloquear)
// 	go func() {
// 		defer stderr.Close()
// 		buf := make([]byte, 4096)
// 		for {
// 			n, rerr := stderr.Read(buf)
// 			if n > 0 {
// 				log.Printf("[FFmpeg-FB-STDERR] %s", bytes.TrimRight(buf[:n], "\r\n"))
// 			}
// 			if rerr != nil {
// 				return
// 			}
// 		}
// 	}()
// 	return cmd.Wait()
// }

// // indexOf busca la primera aparición de sub en s, o -1 si no está
// func indexOf(s, sub []byte) int {
// 	for i := 0; i <= len(s)-len(sub); i++ {
// 		match := true
// 		for j := 0; j < len(sub); j++ {
// 			if s[i+j] != sub[j] {
// 				match = false
// 				break
// 			}
// 		}
// 		if match {
// 			return i
// 		}
// 	}
// 	return -1
// }

// // RunOutputToMJPEG lee un PNG (ej: blue.png), lo convierte a JPEG y lo guarda en LastJPEGFrame
// func RunOutputToMJPEG(pngPath string) error {
// 	rand.Seed(time.Now().UnixNano())
// 	files := []string{"blue.png", "red.png"}
// 	chosen := files[rand.Intn(len(files))]
// 	f, err := os.Open(chosen)
// 	if err != nil {
// 		log.Printf("[MJPEG] Error abriendo %s: %v", chosen, err)
// 		return err
// 	}
// 	defer f.Close()
// 	img, err := png.Decode(f)
// 	if err != nil {
// 		log.Printf("[MJPEG] Error decodificando PNG: %v", err)
// 		return err
// 	}
// 	var buf bytes.Buffer
// 	err = jpeg.Encode(&buf, img, &jpeg.Options{Quality: 90})
// 	if err != nil {
// 		log.Printf("[MJPEG] Error codificando JPEG: %v", err)
// 		return err
// 	}
// 	LastJPEGMutex.Lock()
// 	LastJPEGFrame = buf.Bytes()
// 	log.Printf("[MJPEG] Frame JPEG %s cargado y almacenado. Tamaño: %d bytes", chosen, len(LastJPEGFrame))
// 	LastJPEGMutex.Unlock()
// 	return nil
// }

// func RunFFmpegMJPEGrand() error {
// 	log.Println("[FFmpeg] Lanzando ffmpeg en modo image2pipe para MJPEG con inserción aleatoria...")

// 	cmd := exec.Command(
// 		"ffmpeg",
// 		"-loglevel", "debug",
// 		"-nostdin",
// 		"-protocol_whitelist", "file,udp,rtp",
// 		"-re",
// 		"-i", "rtp-forwarder.sdp",
// 		"-flags", "low_delay",
// 		"-avioflags", "direct",
// 		"-analyzeduration", "0",
// 		"-probesize", "32k",
// 		"-use_wallclock_as_timestamps", "1",
// 		"-vf", "fps=10,scale=960:540",
// 		"-pix_fmt", "yuvj420p",
// 		"-flush_packets", "1",
// 		"-f", "mjpeg",
// 		"-q:v", "5",
// 		"pipe:1",
// 	)
// 	cmd.Dir = "."

// 	stdout, err := cmd.StdoutPipe()
// 	if err != nil {
// 		log.Printf("error creando StdoutPipe: %v", err)
// 		return err
// 	}
// 	stderr, err := cmd.StderrPipe()
// 	if err != nil {
// 		log.Printf("error creando StderrPipe: %v", err)
// 		return err
// 	}
// 	if err := cmd.Start(); err != nil {
// 		log.Printf("error lanzando ffmpeg: %v", err)
// 		return err
// 	}

// 	// Leer stderr en goroutine
// 	go func() {
// 		defer stderr.Close()
// 		buf := make([]byte, 4096)
// 		for {
// 			n, err := stderr.Read(buf)
// 			if n > 0 {
// 				log.Printf("[FFmpeg-STDERR] %s", buf[:n])
// 			}
// 			if err != nil {
// 				break
// 			}
// 		}
// 	}()

// 	// Leer stdout en goroutine y procesar
// 	go ProcessMJPEGBuffer(stdout, 1) // 10% probabilidad de reemplazo

// 	return cmd.Wait()
// }

// func DecideFrame(webcamFrame []byte, replaceProb float32, r *rand.Rand) []byte {
// 	if r.Float32() < replaceProb {
// 		pngFiles := []string{"blue.png", "red.png"}
// 		chosen := pngFiles[r.Intn(len(pngFiles))]
// 		f, err := os.Open(chosen)
// 		if err != nil {
// 			log.Printf("[MJPEG-RAND] No se pudo abrir %s: %v", chosen, err)
// 			return webcamFrame
// 		}
// 		defer f.Close()

// 		img, err := png.Decode(f)
// 		if err != nil {
// 			log.Printf("[MJPEG-RAND] Error decodificando PNG %s: %v", chosen, err)
// 			return webcamFrame
// 		}

// 		var b bytes.Buffer
// 		if err := jpeg.Encode(&b, img, &jpeg.Options{Quality: 90}); err != nil {
// 			log.Printf("[MJPEG-RAND] Error codificando JPEG de %s: %v", chosen, err)
// 			return webcamFrame
// 		}

// 		log.Printf("[MJPEG-RAND] Frame reemplazado por %s", chosen)
// 		return b.Bytes()
// 	}
// 	return webcamFrame
// }

// // ProcessMJPEGBuffer lee stdout (ffmpeg), extrae JPEGs completos y actualiza LastJPEGFrame.
// // replaceProb es la probabilidad de reemplazar por PNGs.
// func ProcessMJPEGBuffer(stdout io.ReadCloser, replaceProb float32) {
// 	defer stdout.Close()
// 	// RNG local (no usar rand.Seed global)
// 	r := rand.New(rand.NewSource(time.Now().UnixNano()))

// 	// Acumulador dinámico para ensamblar frames
// 	buf := make([]byte, 0, 2*1024*1024) // reserva inicial 2MB
// 	const maxBuffer = 8 * 1024 * 1024   // 8MB límite razonable
// 	jpegSOI := []byte{0xFF, 0xD8}
// 	jpegEOI := []byte{0xFF, 0xD9}

// 	// leer en chunks modestos
// 	tmp := make([]byte, 16*1024) // 16KB

// 	for {
// 		n, err := stdout.Read(tmp)
// 		if n > 0 {
// 			buf = append(buf, tmp[:n]...)

// 			// recortar si se supera el tamaño máximo, preservando últimos bytes
// 			if len(buf) > maxBuffer {
// 				// copia la porción que queremos conservar para liberar array viejo
// 				startKeep := len(buf) - maxBuffer
// 				newBuf := make([]byte, maxBuffer)
// 				copy(newBuf, buf[startKeep:])
// 				buf = newBuf
// 				log.Println("[FFmpeg] Warning: buffer recortado a maxBuffer")
// 			}

// 			// extraer tantos frames completos como hayan
// 			for {
// 				start := bytes.Index(buf, jpegSOI)
// 				if start < 0 {
// 					// no hay inicio completo
// 					break
// 				}
// 				endRel := bytes.Index(buf[start:], jpegEOI)
// 				if endRel < 0 {
// 					// no hay EOI aún (frame incompleto) -> esperar a más datos
// 					break
// 				}
// 				end := start + endRel + 2 // incluir EOI

// 				// copiar el frame completo a memoria nueva (independiente de buf)
// 				webcamFrame := make([]byte, end-start)
// 				copy(webcamFrame, buf[start:end])

// 				// decidir reemplazo (puede dejar el frame tal cual o devolver PNG convertido)
// 				finalFrame := DecideFrame(webcamFrame, replaceProb, r)

// 				// almacenar en la variable compartida (protegida por mutex)
// 				LastJPEGMutex.Lock()
// 				LastJPEGFrame = finalFrame
// 				LastJPEGMutex.Unlock()

// 				// avanzar el buffer
// 				buf = buf[end:]
// 			}
// 		}
// 		if err != nil {
// 			if err != io.EOF {
// 				log.Printf("[FFmpeg] Error leyendo stdout: %v", err)
// 			}
// 			break
// 		}
// 	}
// 	log.Println("[FFmpeg] Finalizó lectura de frames JPEG.")
// }
